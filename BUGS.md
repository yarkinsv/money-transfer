## 1) Избыточные вызовы в getAccountByUser

Первое что бросилось в глаза, так это вызов getAllAccounts в функции getAccountByUser. Данный технологический казус был видел ещё из профайлера и подтвердился после перехода к исходеым кодам. Мой уровень познаний в Java позволяет предположить, что после выборки из базы конкретного аккаунта, функция выбирает ещё раз ВСЕ аккаунты и ищет в них найденный. Не добавляет дополнительных полей и не связывает больше ни с какими таблицами. Так что простым решением этой задачи будет возврат переменной acc уже в теле условия 
 if (rs.next()) и если это условие не выполняется, вернуть null.
 
 ## 2) Отсутствие AUTOINCREMENT у поля UserID таблицы Users
 
 В связи с этим каждый раз для добавления нового пользователя автор вызывает getAllUsers и счситает крайний ID кодом. 
 Здесь есть 2 более оптимальных подхода:  
 - получать SELECT MAX(UserID) FROM Users перед вставкой, инкрементировать полученное значения и писать в ID
 - сделать полю UserID AUTOINCREMENT и вообще не передавать ID, что и считаю самым оптимальным вариантом.
 
## 3) Неиспользуемая переменная fetched

В классе UserDAOImpl объявлена приватная переменная fetched, в которую помещаются данные в методе getAllUsers,
однако более нигде эта переменная не используется. Закоментил обе строки.

## 4) не используемый импорт
В файле с описанием класса TestAccountDAO есть import java.util.List, который не используется в коде. Закомментил. 

## 5) не используемая переменная allUsers

В классе UserService определена переменная allUsers, куда помещаются данные, однако она более нишде не используется. Закомментировал.

## 6) hashCode всегда возвращает 1

В классе Account описан метод hashCode, который при любом раскладе возвращал 1. Учитывая, что метод getAllAccounts 
предполагает складирование объектов в hashMap, реализация этого метода является критичной с точки зрения 
производительности. Определил его по образу и подобию соответствующего метода для класса User.

## 7) лишние вызовы loadDriver    

Анализируя семплером HotSpot`ы, нашел на 3м месте вызовы DbUtils.loadDriver в огромном количестве. В коде нашел 
действительно, лишние вызовы в методах getUserDAO и getAccountDAO класса H2DAOFactory. Закомментировал таковые.  


PS В качестве объективного параметра, показывающего производительность приложения в целом 
ориентируюсь на результаты работы скрипта run_tests.py. 
В результате оптимизации Execution time на при тысяче пользователей снизился с 
- average: 0.061 
до 
- average: 0.051