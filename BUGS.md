## 1) Избыточные вызовы в getAccountByUser

Первое что бросилось в глаза, так это вызов getAllAccounts в функции getAccountByUser. Данный технологический казус был видел ещё из профайлера и подтвердился после перехода к исходеым кодам. Мой уровень познаний в Java позволяет предположить, что после выборки из базы конкретного аккаунта, функция выбирает ещё раз ВСЕ аккаунты и ищет в них найденный. Не добавляет дополнительных полей и не связывает больше ни с какими таблицами. Так что простым решением этой задачи будет возврат переменной acc уже в теле условия 
 if (rs.next()) и если это условие не выполняется, вернуть null.
 
 ## 2) Отсутствие AUTOINCREMENT у поля UserID таблицы Users
 
 В связи с этим каждый раз для добавления нового пользователя автор вызывает getAllUsers и счситает крайний ID кодом. 
 Здесь есть 2 более оптимальных подхода:  
 - получать SELECT MAX(UserID) FROM Users перед вставкой, инкрементировать полученное значения и писать в ID
 - сделать полю UserID AUTOINCREMENT и вообще не передавать ID, что и считаю самым оптимальным вариантом.
 
## 3) Неиспользуемая переменная fetched

В классе UserDAOImpl объявлена приватная переменная fetched, в которую помещаются данные в методе getAllUsers,
однако более нигде эта переменная не используется. Закоментил обе строки.

## 4) не используемый импорт
В файле с описанием класса TestAccountDAO есть import java.util.List, который не используется в коде. Закомментил. 

## 5) не используемая переменная allUsers

В классе UserService определена переменная allUsers, куда помещаются данные, однако она более нишде не используется. Закомментировал.

## 6) hashCode всегда возвращает 1

В классе Account описан метод hashCode, который при любом раскладе возвращал 1. Учитывая, что метод getAllAccounts 
предполагает складирование объектов в hashMap, реализация этого метода является критичной с точки зрения 
производительности. Определил его по образу и подобию соответствующего метода для класса User.

## 7) лишние вызовы loadDriver    

Анализируя семплером HotSpot`ы, нашел на 3м месте вызовы DbUtils.loadDriver в огромном количестве. В коде нашел 
действительно, лишние вызовы в методах getUserDAO и getAccountDAO класса H2DAOFactory. Закомментировал таковые.  


PS В качестве объективного параметра, показывающего производительность приложения в целом 
ориентируюсь на результаты работы скрипта run_tests.py. 
В результате оптимизации Execution time на при тысяче пользователей снизился с 
- average: 0.061 
до 
- average: 0.051

# Тестирование различных GC

При тестировании приложения с различными GC не было выведено преимущества одного перед другим по потреблению CPU, таковое было минимальным, иногда подпрыгивало до 0,3% для всех, 
так что главным критерием оценки была эффективность очистки памяти. Анализируя статистику через jstat -gcutil также сложно отдать какое-либо предпочтение одному из GS так как для все показатели сопоставимы и минимальны.  

При тестировании на оптимизированном и на неоптимизированном приложении результаты оказались различными. 
Так, на неоптимизированном приложенни лучше всего себя показал ParallelGC с количеством потоков 10. При использовании его 
размер уже через минуту вышел на уровень ~ 115 Мбайт и устойчиво там держался, пик объёма используемой памяти не превышал 75 Мбайт. 
Худшую работу показал G1. Размер хипа после запуска приложения так и остался на начальном уровне в 250Мбайт 
и пиком использования памяти в 135 Мбайт.  

При тестровании различных GC на оптимизированном приложении лучший результат показал CMS в виде CMSParallelRemarkEnabled, 
который достаточно быстро привёл размер хипа к отметке в 160Мбайт и продолжил держать таковой в процессе работы программы. 
Худшим остался также G1.    

 