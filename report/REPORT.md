## Профилирование JVM приложения

### Праметры системы

| Название      | Значение                                 |
| ------------- |------------------------------------------|
| ПК            | Lenovo ThinkPad T570                     |
| Процессор     | Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz |
| ОЗУ           | 8192 MB DDR4 @ 2133 MHz                  |
| OC            | 16.04.1-Ubuntu x86_64                    |
| Java          | Java(TM) SE Runtime Environment (build 1.8.0_144-b01)|
| JVM           | Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)|
| JMC           | 5.5.1                                    |
| jmap          | из JDK 1.8.0_144                         |
|maven          | 3.3.9                                    |

### Репозиторий.
В репозитории [hh-jvm](https://github.com/eremeykin/hh-jvm/) есть четыре ветки:
* `master` - ветка исходного репозитория [money-transfer](https://github.com/yarkinsv/money-transfer)
* `automation` - ветка автоматизации профилирования, тут созданы файлы `profile.sh` скрипт автоматизирующий профилирование, 
`flight-recorder.jfc` файл с настройками для FlightRecorder и `analyze.py` файл для анализа вывода скрипта `run_tests.py`
* `develop` - ветка с изменениями в java коде для улучшения производительности.
* `report` - ветка с этим отчетом
Стадии экспетиментов помечены тегами `stage_<#стадии>`
Дампы памяти и записи параметров на github не выложены, они знимают много места.

### Стадии экспериментов
Эксперименты проводятся в несколько стадий, каждая стадия отличается от предыдущей изменениями в коде и на каждой стадии снимаются показатели производительности текущей версии кода. Всего есть 4 стадии :
* Стадия 0 (тег `stage_0`): код без изменений
На этой стадии выделяются основные ошибки, которые удается найти с помощью профилировщика.
* Стадия 1 (тег `stage_1`): код содержит исправления, найденные на предыдущей стадии, а также при инспекции кода
* Стадия 2 (тег `stage_2`): реализация DAO переписана, хранение реализовано в структкрах данных Java.
* Стадия 3 (тег `stage_3`): анализ различных GC

### Инструменты
Для замеров используются следующие инструменты:
* самописный bash скрипт `profile.sh` для автоматизации замеров и обеспечения хотябы небольшой степени воспроизводимости экспериментов.
* самописный python скрипт `analyze.py` для построения графика времени выполнения сценария 1.
* [FlightRecorder](https://docs.oracle.com/javacomponents/jmc-5-5/jfr-runtime-guide/about.htm) для записи `jfr` файлов с различными измеряемыми параметрами, перечисленными в файле `flight-recorder.jfc`
* [Java Mission Control](https://www.oracle.com/technetwork/java/javaseproducts/mission-control/index.html) для анализа `jfr` файлов. Файлы `jfr` объемные и в репозиторий не входят.
* [jmap](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html) для сохранения бинарный дампов памяти. Дампы большие, в репозиторий не входят.
* [jvisualvm](https://docs.oracle.com/javase/8/docs/technotes/guides/visualvm/index.html) для анализа дампов памяти и фильтарции объектов по пакету

### Замеряемые величины.
Согласно заданию, требуется контролировать следующие параметры:
* На сколько загружен CPU - оценивается по записям FlightRecorder
* Сколько в среднем потребляется памяти, заметен ли в программе memory leak - оценивается по записям FlightRecorder
* Как часто происходит сборка мусора - оценивается по записям FlightRecorder, тут же оцениваются дампы памяти `.hprof` с помощью jvisualvm
* Сколько в среднем выполняется запуск сценария 1, как быстро увеличивается это время - оценивается по графику, построенному с помошью `analyze.py` 
* Какие операции из значимых (т.е. без учета работы системных функций, в т.ч. веб сервера) занимают больше всего процессорного времени - оценивается по записям FlightRecorder
                                                                                                                                                     
### Методика
В `run_test.py` добавлен вывод прошедшего с момента запуска времени, этот вывод мы будем перенаправлять в файл `.plg` (python log) и потом анализировать.
На каждой стадии запускаем самописный `profile.sh` скрипт командой
`./profile.sh --clear && ./profile.sh --dump && sleep 30 && ./profile.sh`
* `./profile.sh --clear` чистит старые дампы и `jfr` файлы и делает `mvn clean install`
* `./profile.sh --dump` запускает jar-ник и раз в 2 мин делает дамп через `jmap` в течении 10 мин
* `./profile.sh` - записывает jfr файл в течении 10 мин с помощью FlightRecorder и JMC .
*Таким образом, сохранение дампов и запись jfr файлов происходит на разных запусках jar-ника.*

После выполнения скрипта получаем файлы:
* два jfr - один тот, в процессе записи которого не создавались дампы, а второй записывался одновременно с созданием дампов. Для анализа интересен первый
* два plg файла, это файлы output потока python скрипта `run_test.py`, в который мы еще добавили время для каждой итерации. Их также два так как один во вермя "чистого" прогона, а второй во время сохранения дампов памяти. Инетересен первый. 
* дампы памяти, их как парвило 5, так как 10 минут пишем через каждые 2 мин. Анализируем средниий, третий, созданный через 6 мин после начала записи 
Полученные файлы анализируются с помощью jvisualvm (для дампов) и JMC (для .jfr), а также самописным python скриптом `analyze.py`(для построения графика времени выполнения сценария 1 по .plg файлу)

### Стадия 0. 
Анилиз производительности приложения до изменений кода.
* Выясняется, что сохранение дампов во время работы практически не сказывается на производительности, поэтому на самом деле можно запускать один раз на 10 мин `./profile.sh --dump`, вместо того чтобы за первый проход собирать дампы, а за второй писать события FlightRecorder'ом.

* *На сколько загружен CPU?*
Анализируем загрузку CPU из записанного jfr файла. Она в среднем составляет 23%. 
![cpu](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_0/cpu.png)

* *Сколько в среднем потребляется памяти, заметен ли в программе memory leak?*
Изпользование heap от 50 Мб до 145Мб:
![memory](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_0/memory.png)
Дамп №3 
![dump3](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_0/dump3.png)
Относительно много объектов `Account` и `User`, почему-то создано несколько объектов типа `*DAOImpl`. 

* *Как часто происходит сборка мусора?*
За время эксперимента (10мин 11с) произошла 717 раз. Средняя пауза 2 ms 111 μs, максимальная 99 ms 146 μs. 

* *Cколько в среднем выполняется запуск сценария 1, как быстро увеличивается это время?*
На графике показано среднее время `Execution time average` и текщее время `Execution time last` в секундах зависимости от числа выполнения сценария 1 `Function play_scenario_1 called`. 
Текущее время выросло с 0.03 с до  0.4с за 3850 выполнений сценария.
![pyplot](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_0/pyplot.png)


* *Какие операции из значимых (т.е. без учета работы системных функций, в т.ч. веб сервера) занимают больше всего процессорного времени?*
Семплирование, примененное при записи, имеет ограниченную точность и общее число вызова значимых функций не велико, 
в основном процессор выполняет функции из jdk или веб сервера, но оценить узкие места можно при помощи таблицы: 
![hotmethods](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_0/hotmethods.png)

* **ВЫВОДЫ СТАДИИ 0**
1) Проверить как создаются и куда сохраняются объекты `Account` и `User`.
2) Проверить почему создается много объектов типа `*DAOImpl` и `H2DAOFactory`
3) Проверить вызов методов `AccountDAOImpl.getAllAccounts()`, `UserDAOImpl.getAllUsers()`

### Стадия 1. 
При анализе найдено, что
1) Можно переиспользовать `DAOImpl` так как это объекты без состояния
2) Есть утечка памяти, когда в объекте `UserDAOImpl` сохраняются неиспользуемые объекты `User`

Проверяем как исправления повлияют на результат. 

* *На сколько загружен CPU?*
Анализируем загрузку CPU из записанного jfr файла. Она в среднем составляет 23%. 
![cpu](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_1/cpu.png)

* *Сколько в среднем потребляется памяти, заметен ли в программе memory leak?*
Изпользование heap от 50 Мб до 145Мб:
![memory](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_1/memory.png)
Дамп №3 
![dump3](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_1/dump3.png)
Относительно много объектов `Account` и `User`, почему-то создано несколько объектов типа `*DAOImpl`. 

* *Как часто происходит сборка мусора?*
За время эксперимента (10мин 11с) произошла 717 раз. Средняя пауза 2 ms 111 μs, максимальная 99 ms 146 μs. 

* *Cколько в среднем выполняется запуск сценария 1, как быстро увеличивается это время?*
На графике показано среднее время `Execution time average` и текщее время `Execution time last` в секундах зависимости от числа выполнения сценария 1 `Function play_scenario_1 called`. 
Текущее время выросло с 0.03 с до  0.4с за 3850 выполнений сценария.
![pyplot](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_0/pyplot.png)


* *Какие операции из значимых (т.е. без учета работы системных функций, в т.ч. веб сервера) занимают больше всего процессорного времени?*
Семплирование, примененное при записи, имеет ограниченную точность и общее число вызова значимых функций не велико, 
в основном процессор выполняет функции из jdk или веб сервера, но оценить узкие места можно при помощи таблицы: 
![hotmethods](https://raw.githubusercontent.com/eremeykin/hh-jvm/report/img/stage_0/hotmethods.png)

* **ВЫВОДЫ СТАДИИ 1**
